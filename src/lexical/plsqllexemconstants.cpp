#include "plsqldelimeters.h"
#include "plsqlidentifiers.h"
#include "plsqlliteral.h"

#include <cctype>
#include <unordered_set>

const std::unordered_map<string,Delimiter> DELEMITER_NAMES = {
  {STR("+") ,Delimiter::ADDITION_OPERATOR},
  {STR(":="),Delimiter::ASSIGNMENT_OPERATOR},
  {STR("=>"),Delimiter::ASSOCIATION_OPERATOR},
  {STR("\%"),Delimiter::ATTRIBUTE_INDICATOR},
  {STR("'") ,Delimiter::CHARACTER_STRING_DELIMITER},
  {STR(".") ,Delimiter::COMPONENT_INDICATOR},
  {STR("||"),Delimiter::CONCATENATION_OPERATOR},
  {STR("/") ,Delimiter::DIVISION_OPERATOR},
  {STR("**"),Delimiter::EXPONENTIATION_OPERATOR},
  {STR("(") ,Delimiter::EXPRESSION_OR_LIST_DELIMITER_BEGIN},
  {STR(")") ,Delimiter::EXPRESSION_OR_LIST_DELIMITER_END},
  {STR(":") ,Delimiter::HOST_VARIABLE_INDICATOR},
  {STR(",") ,Delimiter::ITEM_SEPARATOR},
  {STR("<<"),Delimiter::LABEL_DELIMITER_BEGIN},
  {STR(">>"),Delimiter::LABEL_DELIMITER_END},
  {STR("/*"),Delimiter::MULTILINE_COMMENT_DELIMITER_BEGIN},
  {STR("*/"),Delimiter::MULTILINE_COMMENT_DELIMITER_END},
  {STR("*") ,Delimiter::MULTIPLICATION_OPERATOR},
  {STR("\""),Delimiter::QUOTED_IDENTIFIER_DELIMITER},
  {STR(".."),Delimiter::RANGE_OPERATOR},
  {STR("=") ,Delimiter::RELATIONAL_OPERATOR_EQUAL},
  {STR("<>"),Delimiter::RELATIONAL_OPERATOR_NOT_EQUAL},
  {STR("!="),Delimiter::RELATIONAL_OPERATOR_NOT_EQUAL},
  {STR("~="),Delimiter::RELATIONAL_OPERATOR_NOT_EQUAL},
  {STR("^="),Delimiter::RELATIONAL_OPERATOR_NOT_EQUAL},
  {STR("<") ,Delimiter::RELATIONAL_OPERATOR_LESS_THAN},
  {STR(">") ,Delimiter::RELATIONAL_OPERATOR_GREATER_THAN},
  {STR("<="),Delimiter::RELATIONAL_OPERATOR_LESS_THAN_OR_EQUAL},
  {STR(">="),Delimiter::RELATIONAL_OPERATOR_GREATER_THAN_OR_EQUAL},
  {STR("@") ,Delimiter::REMOTE_ACCESS_INDICATOR},
  {STR("--"),Delimiter::SINGLELINE_COMMENT_INDICATOR},
  {STR(";") ,Delimiter::STATEMENT_TERMINATOR},
  {STR("-") ,Delimiter::SUBTRACTION_OR_NEGATION_OPERATOR}
};

//the map value show if delimiter has secons part
const std::unordered_map<character,bool> DELEMITER_FIRST_PARTS = {
  {STR('+') ,false},
  {STR(':') ,true },
  {STR('=') ,true },
  {STR('\%'),false},
  {STR('\''),false},
  {STR('.') ,true },
  {STR('|') ,true },
  {STR('/') ,true },
  {STR('*') ,true },
  {STR('(') ,false},
  {STR(')') ,false},
  {STR(',') ,false},
  {STR('"') ,false},
  {STR('!') ,true },
  {STR('~') ,true },
  {STR('^') ,true },
  {STR('<') ,true },
  {STR('>') ,true },
  {STR('@') ,false},
  {STR('-') ,true },
  {STR(';') ,false}
};

const size_t MAX_IDENTIFIER_SIZE = 30;

bool isOrdinaryIdentifierCharacter(character c)
{
  return isalpha(c) || isdigit(c) || (c==STR('$')) || (c==STR('#')) || (c==STR('_'));
}

static const std::unordered_map<Boolean,string> BOOL_STR = {
  {Boolean::FALSE,STR("FALSE")},
  {Boolean::TRUE,STR("TRUE")},
  {Boolean::THE_NULL,STR("NULL")}
};

static const std::unordered_map<string,Boolean> BOOLEANS = {
  {STR("TRUE"),Boolean::TRUE},
  {STR("FALSE"),Boolean::FALSE},
  {STR("NULL"),Boolean::THE_NULL}
};

string to_string(Boolean val)
{
  return BOOL_STR.at(val);
}

static const std::unordered_map<Literal,string> literal_str = {
  {Literal::INTEGER,STR("INTEGER")},
  {Literal::FLOAT,  STR("FLOAT")},
  {Literal::STRING, STR("STRING")},
  {Literal::BOOLEAN,STR("BOOLEAN")}
};

string to_string(Literal val)
{
  return literal_str.at(val);
}

bool isBoolean(const string& str)
{
  return BOOLEANS.find(str)!=BOOLEANS.end();
}

Boolean toBoolean(const string& str)
{
  return BOOLEANS.at(str);
}

static const std::unordered_set<string> KEY_WORDS = {
  STR("A"),
  STR("ADD"),
  STR("AGENT"),
  STR("AGGREGATE"),
  STR("ARRAY"),
  STR("ATTRIBUTE"),
  STR("AUTHID"),
  STR("AVG"),
  STR("BFILE_BASE"),
  STR("BINARY"),
  STR("BLOB_BASE"),
  STR("BLOCK"),
  STR("BODY"),
  STR("BOTH"),
  STR("BOUND"),
  STR("BULK"),
  STR("BYTE"),
  STR("C"),
  STR("CALL"),
  STR("CALLING"),
  STR("CASCADE"),
  STR("CHAR"),
  STR("CHAR_BASE"),
  STR("CHARACTER"),
  STR("CHARSET"),
  STR("CHARSETFORM"),
  STR("CHARSETID"),
  STR("CLOB_BASE"),
  STR("CLOSE"),
  STR("COLLECT"),
  STR("COMMENT"),
  STR("COMMIT"),
  STR("COMMITTED"),
  STR("COMPILED"),
  STR("CONSTANT"),
  STR("CONSTRUCTOR"),
  STR("CONTEXT"),
  STR("CONTINUE"),
  STR("CONVERT"),
  STR("COUNT"),
  STR("CURRENT"),
  STR("CUSTOMDATUM"),
  STR("DANGLING"),
  STR("DATA"),
  STR("DATE"),
  STR("DATE_BASE"),
  STR("DAY"),
  STR("DEFINE"),
  STR("DELETE"),
  STR("DETERMINISTIC"),
  STR("DOUBLE"),
  STR("DURATION"),
  STR("ELEMENT"),
  STR("ELSIF"),
  STR("EMPTY"),
  STR("ESCAPE"),
  STR("EXCEPT"),
  STR("EXCEPTIONS"),
  STR("EXECUTE"),
  STR("EXISTS"),
  STR("EXIT"),
  STR("EXTERNAL"),
  STR("FINAL"),
  STR("FIXED"),
  STR("FLOAT"),
  STR("FORALL"),
  STR("FORCE"),
  STR("GENERAL"),
  STR("HASH"),
  STR("HEAP"),
  STR("HIDDEN"),
  STR("HOUR"),
  STR("IMMEDIATE"),
  STR("INCLUDING"),
  STR("INDICATOR"),
  STR("INDICES"),
  STR("INFINITE"),
  STR("INSTANTIABLE"),
  STR("INT"),
  STR("INTERFACE"),
  STR("INTERVAL"),
  STR("INVALIDATE"),
  STR("ISOLATION"),
  STR("JAVA"),
  STR("LANGUAGE"),
  STR("LARGE"),
  STR("LEADING"),
  STR("LENGTH"),
  STR("LEVEL"),
  STR("LIBRARY"),
  STR("LIKE2"),
  STR("LIKE4"),
  STR("LIKEC"),
  STR("LIMIT"),
  STR("LIMITED"),
  STR("LOCAL"),
  STR("LONG"),
  STR("LOOP"),
  STR("MAP"),
  STR("MAX"),
  STR("MAXLEN"),
  STR("MEMBER"),
  STR("MERGE"),
  STR("MIN"),
  STR("MINUTE"),
  STR("MOD"),
  STR("MODIFY"),
  STR("MONTH"),
  STR("MULTISET"),
  STR("NAME"),
  STR("NAN"),
  STR("NATIONAL"),
  STR("NATIVE"),
  STR("NCHAR"),
  STR("NEW"),
  STR("NOCOPY"),
  STR("NUMBER_BASE"),
  STR("OBJECT"),
  STR("OCICOLL"),
  STR("OCIDATE"),
  STR("OCIDATETIME"),
  STR("OCIDURATION"),
  STR("OCIINTERVAL"),
  STR("OCILOBLOCATOR"),
  STR("OCINUMBER"),
  STR("OCIRAW"),
  STR("OCIREF"),
  STR("OCIREFCURSOR"),
  STR("OCIROWID"),
  STR("OCISTRING"),
  STR("OCITYPE"),
  STR("OLD"),
  STR("ONLY"),
  STR("OPAQUE"),
  STR("OPEN"),
  STR("OPERATOR"),
  STR("ORACLE"),
  STR("ORADATA"),
  STR("ORGANIZATION"),
  STR("ORLANY"),
  STR("ORLVARY"),
  STR("OTHERS"),
  STR("OUT"),
  STR("OVERRIDING"),
  STR("PACKAGE"),
  STR("PARALLEL_ENABLE"),
  STR("PARAMETER"),
  STR("PARAMETERS"),
  STR("PARENT"),
  STR("PARTITION"),
  STR("PASCAL"),
  STR("PIPE"),
  STR("PIPELINED"),
  STR("PRAGMA"),
  STR("PRECISION"),
  STR("PRIOR"),
  STR("PRIVATE"),
  STR("RAISE"),
  STR("RANGE"),
  STR("RAW"),
  STR("READ"),
  STR("RECORD"),
  STR("REF"),
  STR("REFERENCE"),
  STR("RELIES_ON"),
  STR("REM"),
  STR("REMAINDER"),
  STR("RENAME"),
  STR("RESULT"),
  STR("RESULT_CACHE"),
  STR("RETURN"),
  STR("RETURNING"),
  STR("REVERSE"),
  STR("ROLLBACK"),
  STR("ROW"),
  STR("SAMPLE"),
  STR("SAVE"),
  STR("SAVEPOINT"),
  STR("SB1"),
  STR("SB2"),
  STR("SB4"),
  STR("SECOND"),
  STR("SEGMENT"),
  STR("SELF"),
  STR("SEPARATE"),
  STR("SEQUENCE"),
  STR("SERIALIZABLE"),
  STR("SET"),
  STR("SHORT"),
  STR("SIZE_T"),
  STR("SOME"),
  STR("SPARSE"),
  STR("SQLCODE"),
  STR("SQLDATA"),
  STR("SQLNAME"),
  STR("SQLSTATE"),
  STR("STANDARD"),
  STR("STATIC"),
  STR("STDDEV"),
  STR("STORED"),
  STR("STRING"),
  STR("STRUCT"),
  STR("STYLE"),
  STR("SUBMULTISET"),
  STR("SUBPARTITION"),
  STR("SUBSTITUTABLE"),
  STR("SUM"),
  STR("SYNONYM"),
  STR("TDO"),
  STR("THE"),
  STR("TIME"),
  STR("TIMESTAMP"),
  STR("TIMEZONE_ABBR"),
  STR("TIMEZONE_HOUR"),
  STR("TIMEZONE_MINUTE"),
  STR("TIMEZONE_REGION"),
  STR("TRAILING"),
  STR("TRANSACTION"),
  STR("TRANSACTIONAL"),
  STR("TRUSTED"),
  STR("UB1"),
  STR("UB2"),
  STR("UB4"),
  STR("UNDER"),
  STR("UNSIGNED"),
  STR("UNTRUSTED"),
  STR("USE"),
  STR("USING"),
  STR("VALIST"),
  STR("VALUE"),
  STR("VARIABLE"),
  STR("VARIANCE"),
  STR("VARRAY"),
  STR("VARYING"),
  STR("VOID"),
  STR("WHILE"),
  STR("WORK"),
  STR("WRAPPED"),
  STR("WRITE"),
  STR("YEAR"),
  STR("ZONE")
};

bool isKeyword(const string& identifier)
{
  return KEY_WORDS.find(identifier)!=KEY_WORDS.end();
}

static const std::unordered_set<string> RESERVED_WORDS = {
  STR("ALL"),
  STR("ALTER"),
  STR("AND"),
  STR("ANY"),
  STR("AS"),
  STR("ASC"),
  STR("AT"),
  STR("BEGIN"),
  STR("BETWEEN"),
  STR("BY"),
  STR("CASE"),
  STR("CHECK"),
  STR("CLUSTERS"),
  STR("CLUSTER"),
  STR("COLAUTH"),
  STR("COLUMNS"),
  STR("COMPRESS"),
  STR("CONNECT"),
  STR("CRASH"),
  STR("CREATE"),
  STR("CURSOR"),
  STR("DECLARE"),
  STR("DEFAULT"),
  STR("DESC"),
  STR("DISTINCT"),
  STR("DROP"),
  STR("ELSE"),
  STR("END"),
  STR("EXCEPTION"),
  STR("EXCLUSIVE"),
  STR("FETCH"),
  STR("FOR"),
  STR("FROM"),
  STR("FUNCTION"),
  STR("GOTO"),
  STR("GRANT"),
  STR("GROUP"),
  STR("HAVING"),
  STR("IDENTIFIED"),
  STR("IF"),
  STR("IN"),
  STR("INDEX"),
  STR("INDEXES"),
  STR("INSERT"),
  STR("INTERSECT"),
  STR("INTO"),
  STR("IS"),
  STR("LIKE"),
  STR("LOCK"),
  STR("MINUS"),
  STR("MODE"),
  STR("NOCOMPRESS"),
  STR("NOT"),
  STR("NOWAIT"),
  STR("NULL"),
  STR("OF"),
  STR("ON"),
  STR("OPTION"),
  STR("OR"),
  STR("ORDER"),
  STR("OVERLAPS"),
  STR("PROCEDURE"),
  STR("PUBLIC"),
  STR("RESOURCE"),
  STR("REVOKE"),
  STR("SELECT"),
  STR("SHARE"),
  STR("SIZE"),
  STR("SQL"),
  STR("START"),
  STR("SUBTYPE"),
  STR("TABAUTH"),
  STR("TABLE"),
  STR("THEN"),
  STR("TO"),
  STR("TYPE"),
  STR("UNION"),
  STR("UNIQUE"),
  STR("UPDATE"),
  STR("VALUES"),
  STR("VIEW"),
  STR("VIEWS"),
  STR("WHEN"),
  STR("WHERE"),
  STR("WITH")
};

bool isReservedWord(const string& identifier)
{
  return RESERVED_WORDS.find(identifier)!=RESERVED_WORDS.end();
}
